"use strict";(self.webpackChunkLeo_shaoqiang_blog=self.webpackChunkLeo_shaoqiang_blog||[]).push([[708],{584:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-25dc1529",path:"/react/redux/redux.html",title:"前言",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"问题清单",slug:"问题清单",children:[]},{level:2,title:"Redux 源码目录简介",slug:"redux-源码目录简介",children:[]}],filePathRelative:"react/redux/redux.md",git:{updatedTime:null,contributors:[]}}},202:(n,e,s)=>{s.r(e),s.d(e,{default:()=>g});var a=s(252);const r=(0,a.uE)('<h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h1><p>近日，出于对 Redux 的好奇和想对自己用过的东西知根知底之目的，做了一个 Redux 的自我检测，以便彻底了解其精髓之处。下面我会对使用 Redux 之后产生的疑问做一个清单，用问题导向往下深挖。</p><h2 id="问题清单" tabindex="-1"><a class="header-anchor" href="#问题清单" aria-hidden="true">#</a> 问题清单</h2><hr><ol><li>state 初始化如何让全局都能访问到？</li><li>dispatch 之后，Redux 是如何去处理的？</li><li>reducer 是如何处理的？</li><li>state 中的数据被修改之后，订阅者们如何去收到更新后的数据？</li><li>为什么 redux 的精髓在 combineReducer 和 middleware？</li><li>applyMiddleware 中为什么一个临时变量 dispatch 被赋值了 2 次？</li><li>applyMiddleware 中 middlewareAPI 的 dispatch 为什么要用匿名函数包裹？</li><li>React 发送了 dispatch 之后，如何感知 state 的改变？</li><li>hook 的出现是否会影响 Redux 的使用？</li></ol><hr><h2 id="redux-源码目录简介" tabindex="-1"><a class="header-anchor" href="#redux-源码目录简介" aria-hidden="true">#</a> Redux 源码目录简介</h2><p>Redux 暴露出来的五个接口：</p><ul><li>createStore （会创建一个 store 及其相应的 dispatch 和 subscribe 操作）</li><li>combineReducers (合并多个 reducer 为一个总的 reducer)</li><li>bindActionCreators (返回包裹 dispatch 的函数可以直接使用。 一般用在 mapDispatchToProps 里)</li><li>applyMiddleware (提供中间件，如 redux-thunk、redux-logger)</li><li>compose (combineReducers 中会用到的工具函数)</li></ul><p>我们将通过上述接口来一一解答我们提出的问题。ps：以下源码均是简化之后的代码</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>dispatch 之后，Redux 是如何去处理的？\nstate 中的数据被修改之后，页面如何去收到更新后的数据？\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这些答案在 createStore.js 中，先来看看代码结构：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>createStore(reducer, preloadedState, enhancer) {\n  // 转换参数\n  if (typeof preloadedState === &#39;function&#39; &amp;&amp; typeof enhancer === &#39;undefined&#39;) {\n    enhancer = preloadedState\n    preloadedState = undefined\n  }\n  let currentReducer = reducer // 当前的reducer，支持通过 store.replaceReducer 方式动态替换 reducer，为代码热替换提供可能。（之后会写一篇 react-redux 的文章来解读）\n  let currentState = preloadedState // 当前的state\n  let currentListeners = [] // 存储更新函数的数组\n  let nextListeners = currentListeners // 下次dispatch将会触发的更新函数数组\n  let isDispatching = false //类似一把锁，如果正在dispatch action，那么就做一些限制\n\n  function getState() {\n    // 返回当前的state， 可以调用store.getState()获取到store中的数据，\n    ...\n  }\n\n  function subscribe(listener) {\n    // 订阅一个更新函数（listener），实际上的订阅操作就是把listener放入一个listeners数组\n    // 该方法会返回一个 unSubscribe() 函数，以便从数组中删除该监听函数。\n    // 但是注意，这两个操作都是在dispatch不执行时候进行的。因为dispatch执行时候会循环执行更新函数，要保证listeners数组在这时候不能被改变\n    ...\n  }\n\n  function dispatch(action) {\n    // 接收action，调用reducer根据action和当前的state，返回一个新的state\n    // 循环调用listeners数组，执行更新函数，函数内部会通过store.getState()获取state，此时的state为最新的state，完成页面的更新\n    ...\n  }\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n  }\n\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>我们知道页面可以通过 store.getState() 去获取当前的最新状态，而页面如果修改了数据会发送一个 dispatch(type) ，而这个操作便是问题的关键：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error(\n        &#39;Actions must be plain objects. &#39; +\n          &#39;Use custom middleware for async actions.&#39;\n      )\n    }\n\n    if (typeof action.type === &#39;undefined&#39;) {\n      throw new Error(\n        &#39;Actions may not have an undefined &quot;type&quot; property. &#39; +\n          &#39;Have you misspelled a constant?&#39;\n      )\n    }\n    // 正在dispatch的话不能再次dispatch，也就是说不可以同时dispatch两个action\n    if (isDispatching) {\n      throw new Error(&#39;Reducers may not dispatch actions.&#39;)\n    }\n\n    try {\n      isDispatching = true\n      // 获取到当前的state\n      currentState = currentReducer(currentState, action)\n    } finally {\n      isDispatching = false\n    }\n// 此处的会将 subscribe() 里订阅的监听依次跑一遍，数组里面都是需要获取数据的函数。\n    const listeners = (currentListeners = nextListeners)\n\n// 循环执行当前的linstener\n    for (let i = 0; i &lt; listeners.length; i++) {\n      const listener = listeners[i]\n      // 此处并没有将最新状态作为参数传递的原因是因为在监听器中，我们会直接调用 store.getState() 方法去拿到最新的状态，此处只是起到通知作用。这也是数据被更改之后，页面收到通知而去更新数据的方式。\n      listener()\n    }\n    return action\n  }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>解答以上问题：</p><p>Q: dispatch 之后，Redux 是如何去处理的？state 中的数据被修改之后，页面如何去收到更新后的数据？</p><p>A: 首先会利用当前的 reducer、state 以及传入的参数 action 得到新的 state， 然后通过触发监听数组中的函数，让函数中的使用的 store.getState() 再次触发，起到通知数据更新的作用。</p><p>基本上 createStore.js 讲完了，接下来看一下 combineReducers.js 来解决以下问题：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>reducer 是如何处理的？\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 获取到所有reducer的名字，组成数组\nconst reducerKeys = Object.keys(reducers)\n// 最终合成的 reducers 集合\nconst finalReducers = {}\n // 遍历所有的 reducer 使 finalReducers 变成 key( reducer 名字) ： value( reducer 执行函数)的对象。\nfor (let i = 0; i &lt; reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n    if (typeof reducers[key] === &#39;function&#39;) {\n      finalReducers[key] = reducers[key]\n    }\n  }\n   const finalReducerKeys = Object.keys(finalReducers)\n\n// 该函数为 combineReducers.js 核心，主要思路是对传入的 reducer 进行对比，如果任何一个 reducer 返回的 state 与之前的 state 不同，则会返回全新的 state 。(其实这里有个疑问，该函数如果只改了一个 reducer 的 state 数据，都会返回一个全新的 state，为什么会这样处理？)\nreturn function combination (state ={}, action){\n    let hasChanged = false\n    const nextState ={}\n    for (let i =0; i &lt; finalReducerKeys.length; i++) {\n        const key = finalReducerKeys[i]\n        const reducer = finalReducers[key]\n        // 获取每个 reducer 的旧 state\n        const previousStateForKey = state[key]\n        // 根据旧 state 推出新的 state (纯函数的优势：相同的 state 和 action 返回的新 state 也会是不变的。)\n        const nextStateForKey = reducer(previousStateForKey, action)\n        if (typeof nextStateForKey ===&#39;undefined&#39;) {\n            const errorMessage = getUndefinedStateErrorMessage(key, action)\n            throw newError(errorMessage)\n        }\n        // 最后一步 判断是否和之前的 state 是否一致。\n        nextState[key]= nextStateForKey\n        hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n }\n    return hasChanged ? nextState : state\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div>',21),l=(0,a.Uk)("前面的都比较容易理解，相对比较绕的就是 applyMiddleware.js,阅读前需了解"),t={href:"https://zhuanlan.zhihu.com/p/50247174",target:"_blank",rel:"noopener noreferrer"},p=(0,a.Uk)("柯理化"),i=(0,a.Uk)(" 和 node 中间件相关知识, 简单来说就是把一个带有多个参数的函数转换成一系列的嵌套函数。它返回一个新函数，这个新函数期望传入下一个参数。解读 applyMiddleware.js 来回答以下问题："),c=(0,a.uE)('<div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>为什么一个临时变量 dispatch 被赋值了 2 次？\nmiddlewareAPI 的 dispatch 为什么要用匿名函数包裹？\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>接下来我们逐一分析源码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function applyMiddleware(...middlewares) {\n  return (createStore) =&gt;\n      (reducer, preloadedState) =&gt; {\n        const store = createStore(reducer, preloadedState)\n\n        let dispatch = () =&gt; {\n          throw new Error(\n              &#39;Dispatching while constructing your middleware is not allowed. &#39; +\n              &#39;Other middleware would not be applied to this dispatch.&#39;\n          )\n        }\n\n        const middlewareAPI = {\n          getState: store.getState,\n          dispatch: (action, ...args) =&gt; dispatch(action, ...args)\n        }\n        const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))\n\n        dispatch = compose(...chain)(store.dispatch)\n\n        return {\n          ...store,\n          dispatch\n        }\n      }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>可以看到整体构造传入中间件(middlewares),内部函数返回正常的 store 和改造过后的 dispatch。而改造过后的 dispatch 是由 compose(...chain)(store.dispatch) 生成的，首先 compose(...chain) 来自于暴露的第五个接口 compose.js ,它其实就是我们所谓的柯理化处理函数，而 chain 则是一个类似下面的数组形式：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>    next =&gt; action =&gt; {\n        return next(action)\n    }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>compose(...chain) 只是将数组中的函数拼接起来，并未执行。且 compose 最后返回的仍然是一个层层包裹的函数。如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const composedFunc = (next3) =&gt; {\n  return\n  ((next2) =&gt; {\n        return func1(func2(next2))\n    })(func3(next3))\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>而真正执行的时候就是在传入这个 dispatch 参数时 compose(...chain)(dispatch)，这个 dispatch 正是上面的 next3，next2 就是 func3(next3) 的返回值，依次类推，得到如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>func1(func2(func3(dispatch)));\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><div class="language-const ext-const line-numbers-mode"><pre class="language-const"><code>  console.log(&quot;coreFun1 run&quot;);\n  ((action) =&gt; {\n    console.log(&quot;coreFunc2 run&quot;);\n    ((action) =&gt; {\n      console.log(&quot;coreFunc3 run&quot;);\n      dispatch(action);\n    })(action);\n  })(action);\n}\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>根据 node 中间件洋葱模型来看，所有的中间件处理了 action 之后 会往里传递，然后最后在最内层触发 dispatch 之后在将其结果作为参数往外传，最终得到一个全新的函数。</p><p>再顺着源码往上看，</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const store = createStore(reducer, preloadedState)\n\n        let dispatch = () =&gt; {\n          throw new Error(\n              &#39;Dispatching while constructing your middleware is not allowed. &#39; +\n              &#39;Other middleware would not be applied to this dispatch.&#39;\n          )\n        } // 第一次赋值\n\n        const middlewareAPI = {\n          getState: store.getState,\n          dispatch: (action, ...args) =&gt; dispatch(action, ...args)\n        }\nconst chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))\ndispatch = compose(...chain)(store.dispatch) // 第二次赋值\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这段也主要是为了给每个 middleware 基本的 getState 和 dispatch。 解决几个常问到的疑点：</p><ol><li>为什么一个临时变量 dispatch 被赋值了 2 次？ 首先从第一个变量返回的 throw Error 可以看出这段代码希望在 middleware 数组被构建时， dispatch 不应该被调用，否则抛错。而在 middlewareAPI 的 dispatch 中被调用了一次但没触发这个 throw Error，是因为其实直到给 dispatch 第二次赋值时才真正调用 dispatch（我们之前解读到直到 compose 函数传入了(store.dispatch) 之后才会触发调用），所以这时 middlewareAPI 的 dispatch 并不会触发。</li><li>middlewareAPI 的 dispatch 为什么要用匿名函数包裹？ 目的就是如果每个 middleware 对 dispatch 有所改变，middleware 里面的 dispatch 也会相应做出改变（如一问中所说，compose(...chain)(store.dispatch) 触发了 middlewareAPI 的 dispatch 被调用）。</li></ol><blockquote><p>至此解决完 applyMiddleware 的相关问题，redux 的解析也到此结束，如有疑问或者解读错误的地方，还望大佬们指正。</p></blockquote><p>参考链接：</p>',17),b={href:"https://zhuanlan.zhihu.com/p/304688473",target:"_blank",rel:"noopener noreferrer"},u=(0,a.Uk)("读源码理解 Redux Middleware 中间件 - FreewheelLee 的文章"),d={href:"https://zhuanlan.zhihu.com/p/34651008",target:"_blank",rel:"noopener noreferrer"},o=(0,a.Uk)("redux 中间件的原理——从懵逼到恍然大悟 - Dell Lee 的文章"),m={href:"https://zhuanlan.zhihu.com/p/74279078",target:"_blank",rel:"noopener noreferrer"},h=(0,a.Uk)("简单梳理 Redux 的源码与运行机制 - Nero 的文章"),g={render:function(n,e){const s=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.j4)(a.HY,null,[r,(0,a.Wm)("p",null,[l,(0,a.Wm)("a",t,[p,(0,a.Wm)(s)]),i]),c,(0,a.Wm)("p",null,[(0,a.Wm)("a",b,[u,(0,a.Wm)(s)])]),(0,a.Wm)("p",null,[(0,a.Wm)("a",d,[o,(0,a.Wm)(s)])]),(0,a.Wm)("p",null,[(0,a.Wm)("a",m,[h,(0,a.Wm)(s)])])],64)}}}}]);